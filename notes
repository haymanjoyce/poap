PACKAGES, FOLDERS, FILES

Packages are:

src
tests

Folders are:

data
    workbooks
    dataframes
    templates
    styles

charts
    SVGs
    PDFs
    images
    animations

scripts

Root level files are:

.gitignore
LICENSE
log
notes
README
requirements
setup
settings - json file for tool settings (e.g. holding file locations)

Notes:

It is convention to put packages in a folder called src and for src to contain only one package
Src is a folder (not a package) but my editor has automatically made it into a package (by applying an __init__.py file)
Src contains "tool" (the main package)

When using commands in development, without deploying app, you must navigate to entry point directory and treat tool package as entry module (python -m tool)
When deployed, the .toml file puts entry point on PYTHONPATH I think
I have switched from pyproject.toml to setup.py because that is what the Click docs recommend

WORKBOOKS

The user enters and manipulates project data in Excel workbooks (using the Excel spreadsheet app)
Common spreadsheet formats are xlsx, ods, xls, numbers, 123, etc.
Pandas handles csv, xlsx, json, hdf5, and pkl
The spreadsheet formats that we can use are limited by what Pandas can handle
CSV is not suitable as it can only handle one table a time and the tool uses many
We can put sample workbooks in workbooks folder
We can run checks on workbook data before importing it
Eventually might create GUI as alternative to spreadsheet (enabling direct manipulation of df via this GUI)

DATAFRAMES

On import, project data is imported into a df (Pandas dataframe)
Dfs are like the app database
Dfs cannot be directly manipulated by the user
They contain project data, geometry units, meta-data, etc.
There is only one project dataset per dataframe
On import, the tool will raise errors and warnings as required
We can run calculations on the data - preparing it for parsing into SVG (as current or baseline, for example)
We can export selected data from the df as xlsx
Dfs will be linked to workbooks and so we know whether to update an existing df or create a new one
We can display dfs as tables using various Pandas GUI apps (if not Excel)
(Note, Pandas supports converting date ranges into increments)
(Note, in drawsvg2 scaling increases borders which we may not want as we will get border bleed)
May switch from dfs to db in future

TEMPLATES

The templates folder contains template files (csv or json, for example)
A template file will contain the tables and fields needed to create dfs and workbooks (i.e. schemas)
Template files can be used to check existing workbook and df structure
For example, there could be a template for creating a workbook with basic project data only or another which includes styling data

STYLES

Dfs reference the styles folder for default styles (i.e. formatting)
Users can override selected styling data
Style overrides are stored in the df (or the workbook form the user perspective)
We may allow users to create and/or edit their own default style files

SVGs

We can parse single or multiple dataframes into SVG drawings
We may parse one dataframe as the current project and another as a baseline
We may want to create an animated SVG from many dataframes
We will probably use drawsvg2
svgdraw2 handles svg elements as objects which then output svg
The objects will be deleted at end of a given drawing operation
We may need to provide additional arguments (such as framerate, in the case of animations)
Like dfs, SVGs may contain extensive metadata and so users can easily query them
We may have command to open an SVG in a specific app (e.g. browser or Jupyter Notebook)
We may create our own viewer (GUI) using QtSVG

PDFs

We can convert SVGs into PDFs
We may need Ghostscript for this
These are stored in the app folder by default but the user can save to a folder of their choice

IMAGES

We can convert SVGs into raster images (png, fig, tif, etc.)
We probably need Cairo for this, which is not a Python package (and so it will need to be loaded onto the OS)

ANIMATIONS

drawsvg2 supports animation

SCRIPTS

Simple SVGs which reference only one df will be simple enough to create using command line
However, we have [shell] scripts folder in case commands get long (for example, creating an animation referencing many dfs)

DEPENDENCIES

pandas: For handling and manipulating data as dataframes.
json: For working with JSON files, including configuration and style files.
drawsvg2: A library for creating SVG drawings and handling SVG elements.
click: A command-line interface (CLI) framework that simplifies building command-line applications.
pathlib: For handling file paths and operations in a cross-platform manner.
pydantic: For data validation and modeling, especially useful for handling configuration files and input data.
cairosvg: A library that allows converting SVG files to other formats like PNG, PDF, etc.
PySide/PyQt: Libraries for creating graphical user interfaces (GUI) and custom viewers using Qt, which could be useful for the "VIEW" component.
numpy: A library for numerical computations that pandas relies on.
matplotlib-dates: An extension to matplotlib for handling dates and time in plotting.
ghostscript: A library for working with PostScript and PDF files, which could be a dependency for generating PDF files from SVG.

MODULES

commands.py - contains all the CLI commands (may create GUI in future)
compile.py - converts project data into data that is usable by draw module (e.g. geometry units)
draw.py - parses df data into svg
import.py - for importing data
check.py - for checking workbooks
clean.py - for cleaning dfs (cannot clean workbooks)
export.py - for exporting data, typically, as workbook
print.py - for converting svg into pdfs or handling print devices
image.py - for creating raster images
animate.py - for creating animations
utils.py - tools for file handling and other things like helper functions