PACKAGES, FOLDERS, FILES

Packages are:

    src
    tests

Folders are:

    data
        workbooks
        dataframes
        templates
        styles

    scripts

Root level files are:

    .gitignore
    LICENSE
    log
    notes
    README
    requirements
    setup.py - for getting the tool ready for use (in a Python environment)
    config - json file for tool configuration (e.g. holding file locations)

Notes:

It is convention to put packages in a folder called src and for src to contain only one package
Src is a folder (not a package) but my editor has automatically made it into a package (by applying an __init__.py file)
Src contains "tool" (the main package)

In development, you need to run the entry point file (cli.py) from the root directory (PycharmProjects/tool)
python -m src.tool.cli
If you run it from the entry point package (./tool/src/tool) then it won't understand the absolute import statements (and so won't find modules)
python -m tool or python -m cli
But if you use relative imports then setuptools will not find modules in deployment

I have switched from pyproject.toml to setup.py because that is what the Click docs recommend

You can create another virtual environment and test the app there, deploying code straight from project folder by installing the package into the environment

WORKBOOKS

The user enters and manipulates project data in Excel workbooks (using the Excel spreadsheet app)
Common spreadsheet formats are xlsx, ods, xls, numbers, 123, etc.
Pandas handles csv, xlsx, json, hdf5, and pkl
The spreadsheet formats that we can use are limited by what Pandas can handle
CSV may not be suitable as it can only handle one table a time and the tool uses many
The user decides where workbooks are stored (there is no workbook folder in the app's folder structure)
We can run checks (structure and/or data) on workbooks
Eventually might create GUI as alternative to spreadsheet (enabling direct manipulation of df via this GUI)
We can export xlsx from the current dataframe (df)
We can exclude some or all formatting data in the export
By default, we exclude all calculated or derived data (i.e. all the data needed to parse svg)
We can export a blank xlsx or set of csvs (i.e. a template)
Templates are built with reference to the template file and not the current dataframe
We can export a single dataframe as a csv or a workbook with one sheet in it (we need to name the sheet (same thing as df or table))
There are many template files because we want to keep a record of changes to template in case the user uses an old structure

DATAFRAMES

On import, project data is imported into dfs (Pandas dataframes)
Dfs are like the app database
Dfs cannot be directly manipulated by the user
They contain project data, geometry units, meta-data, etc.
Each dataframe corresponds to a sheet in the workbook
The tool does not keep old dataframes but the current set can be exported (pkl)
We can run calculations on the data - preparing it for parsing into SVG (as current or baseline, for example)
Dfs may be linked to workbooks and so we know whether to update an existing df or create a new one
We can display dfs as tables using various Pandas GUI apps (if not Excel)
(Note, Pandas supports converting date ranges into increments)
(Note, in drawsvg2 scaling increases borders which we may not want as we will get border bleed)
May switch from dfs to db in future (which would retain project and version history)

TEMPLATES

The templates folder contains template files (csv or json, for example)
A template file will contain the tables and fields needed to create dfs and workbooks (i.e. schemas)
Template files can be used to check existing workbook and df structure
For example, there could be a template for creating a workbook with basic project data only or another which includes styling data

STYLES

Dfs reference the styles folder for default styles (i.e. formatting)
Users can override selected styling data
Style overrides are stored in the df (or the workbook form the user perspective)
We may allow users to create and/or edit their own default style files

SVGs

We can parse single or multiple dataframes into SVG drawings
We may parse one dataframe as the current project and another as a baseline
We may want to create an animated SVG from many dataframes
We will probably use drawsvg2
svgdraw2 handles svg elements as objects which then output svg
The objects will be deleted at end of a given drawing operation
We may need to provide additional arguments (such as framerate, in the case of animations)
Like dfs, SVGs may contain extensive metadata and so users can easily query them
We may have command to open an SVG in a specific app (e.g. browser or Jupyter Notebook)
We may create our own viewer (GUI) using QtSVG

PDFs

We can convert SVGs into PDFs
We may need Ghostscript for this
These are stored in the app folder by default but the user can save to a folder of their choice

IMAGES

We can convert SVGs into raster images (png, fig, tif, etc.)
We probably need Cairo for this, which is not a Python package (and so it will need to be loaded onto the OS)

ANIMATIONS

drawsvg2 supports animation
Data for a a frame my be kept in the workbook or df (uncertain)

SCRIPTS

Simple SVGs which reference only one df will be simple enough to create using command line
However, we have [shell] scripts folder in case commands get long (for example, creating an animation referencing many dfs)

DEPENDENCIES

pandas: For handling and manipulating data as dataframes.
json: For working with JSON files, including configuration and style files.
drawsvg2: A library for creating SVG drawings and handling SVG elements.
click: A command-line interface (CLI) framework that simplifies building command-line applications.
pathlib: For handling file paths and operations in a cross-platform manner.
pydantic: For data validation and modeling, especially useful for handling configuration files and input data.
cairosvg: A library that allows converting SVG files to other formats like PNG, PDF, etc.
PySide/PyQt: Libraries for creating graphical user interfaces (GUI) and custom viewers using Qt, which could be useful for the "VIEW" component.
numpy: A library for numerical computations that pandas relies on.
matplotlib-dates: An extension to matplotlib for handling dates and time in plotting.
ghostscript: A library for working with PostScript and PDF files, which could be a dependency for generating PDF files from SVG.

MODULES

commands.py - contains all the CLI commands (may create GUI in future)
compile.py - converts project data into data that is usable by draw module (e.g. geometry units)
draw.py - parses df data into svg
import.py - for importing data
check.py - for checking workbooks
clean.py - for cleaning dfs (cannot clean workbooks)
export.py - for exporting data, typically, as workbook
print.py - for converting svg into pdfs or handling print devices
image.py - for creating raster images
animate.py - for creating animations
utils.py - tools for file handling and other things like helper functions